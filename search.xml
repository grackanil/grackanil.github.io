<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NSObject +(void)load 和+(void)initialize 方法的理解]]></title>
    <url>%2F2018%2F01%2F31%2Fruntime-load%2F</url>
    <content type="text"><![CDATA[从 runtime 源码，理解 +(void)load 和 +(void)initialize 方法。 零、官方文档 initializeInitializes the class before it receives its first message. loadInvoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading. 根据文档，+load 方法只要文件被引用就会被调用，所以如果类没有被引进项目,就不会调用 +load。+initialize 方法是在类或者子类的第一个方法（抛一个问题，那 runtime 调用 +load 方法呢，算第一个方法吗？）被调用之前调用，即使类被引用进项目，但没有被使用， +initialize 也不会被调用。两者都只会被调用一次。 一、实验田Demo123456789101112131415161718192021# Father.h 和 Father.m@interface Father : NSObject@end#import &quot;Father.h&quot;#pragma mark - Father@implementation Father+ (void)load &#123; # [self class]; NSLog(@&quot;%s&quot;, __FUNCTION__);&#125;+ (void)initialize &#123; NSLog(@&quot;%s&quot;, __FUNCTION__);&#125;@end 12345678910111213141516# Son .h 和 .m@interface Son : Father@end@implementation Son+ (void)load &#123; # [self class]; NSLog(@&quot;%s&quot;, __FUNCTION__);&#125;+ (void)initialize &#123; NSLog(@&quot;%s&quot;, __FUNCTION__);&#125;@end 12345678910111213141516# Category Active of Son .h and .m@interface Son (Active)@end@implementation Son (Active)+ (void)load &#123; # [self class]; NSLog(@&quot;%s&quot;, __FUNCTION__);&#125;+ (void)initialize &#123; NSLog(@&quot;%s&quot;, __FUNCTION__);&#125;@end 12345678910111213141516# Category Stiff of Son .h and .m@interface Son (Stiff)@end@implementation Son (Stiff)+ (void)load &#123; # [self class]; NSLog(@&quot;%s&quot;, __FUNCTION__);&#125;+ (void)initialize &#123; NSLog(@&quot;%s&quot;, __FUNCTION__);&#125;@end 结果如下12345# 父类的方法优先于子类的方法，类中的方法优先于类别中的方法。2018-02-01 10:59:11.957088+0800 LoadAndInitializePlot[21886:9588221] +[Father load]2018-02-01 10:59:11.957867+0800 LoadAndInitializePlot[21886:9588221] +[Son load]2018-02-01 10:59:11.957997+0800 LoadAndInitializePlot[21886:9588221] +[Son(Active) load]2018-02-01 10:59:11.958132+0800 LoadAndInitializePlot[21886:9588221] +[Son(Stiff) load] 在 Father load 中添加 [self class];，结果如下123456# 调用了 Father 中的方法，第一个方法`[self class];`被调用时，在调用方法之前执行 `+initialize` 方法。可以看出，虽然引用了 Son 类，但没有调用 Son 的 `+initalize`，同时 runtime 对 `+(void)load` 的调用不视为调用类的第一个方法，如果是子类 Son 也会调用 `+initialize` 的。2018-02-01 11:03:38.424049+0800 LoadAndInitializePlot[21961:9595895] +[Father initialize]2018-02-01 11:03:38.424803+0800 LoadAndInitializePlot[21961:9595895] +[Father load]2018-02-01 11:03:38.424953+0800 LoadAndInitializePlot[21961:9595895] +[Son load]2018-02-01 11:03:38.425123+0800 LoadAndInitializePlot[21961:9595895] +[Son(Active) load]2018-02-01 11:03:38.425418+0800 LoadAndInitializePlot[21961:9595895] +[Son(Stiff) load] 在 Son load 中添加 [self class];，结果如下两种（在Build Phases -&gt; Compile Sources 中拖动类别的上下顺序，也就是编译的先后顺序）。根据 runtime 对 category 加载过程，一个类的所有类别的方法被取出放在 method_list_t 中，另外，这里的新生成的 category 的方法会先于 早期生成的 category 的方法，倒序添加的。生成所有 method 的 list 之后，将所有的方法 前序 添加到类的方法数组中。原来的类的方法被 category 的方法覆盖，但被覆盖的方法依旧还在里面。这是因为系统调用方法，根据方法名在 method_list 中查找方法，找到第一个名字匹配的方法之后就不继续往下找了。每次调用都是 method_list 中最前面的同名方法，其他的方法仍在 method_list 中。1234567# Son (Stiff) 类别在 Son (Active) 后编译2018-02-01 11:46:45.558933+0800 LoadAndInitializePlot[22604:9665625] +[Father load]2018-02-01 11:46:45.559605+0800 LoadAndInitializePlot[22604:9665625] +[Father initialize]2018-02-01 11:46:45.559735+0800 LoadAndInitializePlot[22604:9665625] +[Son(Stiff) initialize]2018-02-01 11:46:45.559876+0800 LoadAndInitializePlot[22604:9665625] +[Son load]2018-02-01 11:46:45.560021+0800 LoadAndInitializePlot[22604:9665625] +[Son(Active) load]2018-02-01 11:46:45.560125+0800 LoadAndInitializePlot[22604:9665625] +[Son(Stiff) load] 1234567# Son (Active) 类别在 Son (Stiff) 后编译2018-02-01 11:50:33.255480+0800 LoadAndInitializePlot[22659:9671829] +[Father load]2018-02-01 11:50:33.256105+0800 LoadAndInitializePlot[22659:9671829] +[Father initialize]2018-02-01 11:50:33.256236+0800 LoadAndInitializePlot[22659:9671829] +[Son(Active) initialize]2018-02-01 11:50:33.256363+0800 LoadAndInitializePlot[22659:9671829] +[Son load]2018-02-01 11:50:33.256449+0800 LoadAndInitializePlot[22659:9671829] +[Son(Stiff) load]2018-02-01 11:50:33.256531+0800 LoadAndInitializePlot[22659:9671829] +[Son(Active) load] 在 Son load 中添加 [self class];，移除 Son 主类和两个类别中的 +initilize 方法。1234567# `+(void)initialize` 自身未定义，会沿用父类的方法。2018-02-01 11:54:27.282176+0800 LoadAndInitializePlot[22722:9678734] +[Father load]2018-02-01 11:54:27.282749+0800 LoadAndInitializePlot[22722:9678734] +[Father initialize]2018-02-01 11:54:27.282843+0800 LoadAndInitializePlot[22722:9678734] +[Father initialize]2018-02-01 11:54:27.282955+0800 LoadAndInitializePlot[22722:9678734] +[Son load]2018-02-01 11:54:27.283046+0800 LoadAndInitializePlot[22722:9678734] +[Son(Stiff) load]2018-02-01 11:54:27.283157+0800 LoadAndInitializePlot[22722:9678734] +[Son(Active) load] 在 Son load 中添加 [self class];，移除 两个类别的 +initilize 方法。1234567# 根据以上的 runtime 中的分析可知，`+(void)initialize`会“覆盖”类中的方法，只执行一个。2018-02-01 11:56:00.047404+0800 LoadAndInitializePlot[22756:9681679] +[Father load]2018-02-01 11:56:00.051067+0800 LoadAndInitializePlot[22756:9681679] +[Father initialize]2018-02-01 11:56:00.051389+0800 LoadAndInitializePlot[22756:9681679] +[Son initialize]2018-02-01 11:56:00.051745+0800 LoadAndInitializePlot[22756:9681679] +[Son load]2018-02-01 11:56:00.052070+0800 LoadAndInitializePlot[22756:9681679] +[Son(Stiff) load]2018-02-01 11:56:00.052350+0800 LoadAndInitializePlot[22756:9681679] +[Son(Active) load] 一、+(void)load 的理解+load 方法是 Objective-C 中 NSObject 的一个方法，在整个文件刚被加载到运行时，在 main 函数调用之前被 ObjC runtime 调用的钩子方法。 常见理论知识汇总 调用顺序：父类 &gt; 子类 &gt; 分类 调用时机：Objective-C 运行时初始化时，每当有新的镜像library map 到运行时调用。 调用次数：一次 线程安全：load 方法是线程安全的，内部使用了锁，应避免线程阻塞在 load 中。 常见场景：load 中实现 Method Swizzle。 one more thing：如果一个类本身没有 load 方法，不管其父类是否实现 load，都不会调用，主类和分类都执行。 基于 runtime 源码分析针对 runtime 源码 objc4-723 ，做一下探讨。xnu 内核为程序准备好之后，将控制权交个 dyld 负责后续工作，dyld 是 Apple 的动态链接器， the dynamic link editor 的缩写。此过程内核态切换到用户态，dyld 在用户态。 ####_objc_init每当 libSystem 在 library 初始化之前都会调用 _objc_init方法，dyld 在方法中注册 load_images 回调。 123456789101112131415161718192021/************************************************************************ _objc_init* Bootstrap initialization. Registers our image notifier with dyld.* Called by libSystem BEFORE library initialization time**********************************************************************/# pragma mark - ObjC runtime 初始化 注册 load_images 回调void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_2_images, load_images, unmap_image);&#125; load_images所以每当有新的 library 被 map 到 runtime 时，调用 load_images 方法。1234567891011121314151617181920212223242526/************************************************************************ load_images* Process +load in the given images which are being mapped in by dyld.** Locking: write-locks runtimeLock and loadMethodLock**********************************************************************/extern bool hasLoadMethods(const headerType *mhdr);extern void prepare_load_methods(const headerType *mhdr);voidload_images(const char *path __unused, const struct mach_header *mh)&#123; // Return without taking locks if there are no +load methods here. if (!hasLoadMethods((const headerType *)mh)) return; recursive_mutex_locker_t lock(loadMethodLock); // Discover load methods &#123; rwlock_writer_t lock2(runtimeLock); prepare_load_methods((const headerType *)mh); &#125; // Call +load methods (without runtimeLock - re-entrant) call_load_methods();&#125; prepare_load_methods在主类的父类和自身添加到全局静态结构体 loadable_list 中之后，添加主类的分类，将分类添加到全局静态结构体 loadable_categories 中。所以子类优先分类。12345678910111213141516171819202122void prepare_load_methods(const headerType *mhdr)&#123; size_t count, i; runtimeLock.assertWriting(); classref_t *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) &#123; schedule_class_load(remapClass(classlist[i])); &#125; category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) &#123; category_t *cat = categorylist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) continue; // category for ignored weak-linked class realizeClass(cls); assert(cls-&gt;ISA()-&gt;isRealized()); add_category_to_loadable_list(cat); &#125;&#125; schedule_class_load递归调用 schedule_class_load ，在将当前类加入全局静态结构体 loadable_classes 之前，将父类加入其中，待后续加载。保证了父类在子类之前调用 load 方法。1234567891011121314151617181920/************************************************************************ prepare_load_methods* Schedule +load for classes in this image, any un-+load-ed * superclasses in other images, and any categories in this image.**********************************************************************/// Recursively schedule +load for cls and any un-+load-ed superclasses.// cls must already be connected.static void schedule_class_load(Class cls)&#123; if (!cls) return; assert(cls-&gt;isRealized()); // _read_images should realize if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return; // Ensure superclass-first ordering schedule_class_load(cls-&gt;superclass); add_class_to_loadable_list(cls); cls-&gt;setInfo(RW_LOADED); &#125; call_load_methods当 library 加载到运行时，prepare 调用结束，执行 call_load_methods();123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/************************************************************************ call_load_methods* Call all pending class and category +load methods.* Class +load methods are called superclass-first. * Category +load methods are not called until after the parent class&apos;s +load.* * This method must be RE-ENTRANT, because a +load could trigger * more image mapping. In addition, the superclass-first ordering * must be preserved in the face of re-entrant calls. Therefore, * only the OUTERMOST call of this function will do anything, and * that call will handle all loadable classes, even those generated * while it was running.** The sequence below preserves +load ordering in the face of * image loading during a +load, and make sure that no * +load method is forgotten because it was added during * a +load call.* Sequence:* 1. Repeatedly call class +loads until there aren&apos;t any more* 2. Call category +loads ONCE.* 3. Run more +loads if:* (a) there are more classes to load, OR* (b) there are some potential category +loads that have * still never been attempted.* Category +loads are only run once to ensure &quot;parent class first&quot; * ordering, even if a category +load triggers a new loadable class * and a new loadable category attached to that class. ** Locking: loadMethodLock must be held by the caller * All other locks must not be held.**********************************************************************/void call_load_methods(void)&#123; static bool loading = NO; bool more_categories; loadMethodLock.assertLocked(); // Re-entrant calls do nothing; the outermost call will finish the job. if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do &#123; // 1. Repeatedly call class +loads until there aren&apos;t any more while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; // 2. Call category +loads ONCE more_categories = call_category_loads(); // 3. Run more +loads if there are classes OR more untried categories &#125; while (loadable_classes_used &gt; 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO;&#125; 附录：add_class_to_loadable_list 和 add_category_to_loadable_list方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// List of classes that need +load called (pending superclass +load)// This list always has superclasses first because of the way it is constructedstatic struct loadable_class *loadable_classes = nil;static int loadable_classes_used = 0;static int loadable_classes_allocated = 0;// List of categories that need +load called (pending parent class +load)static struct loadable_category *loadable_categories = nil;static int loadable_categories_used = 0;static int loadable_categories_allocated = 0;/************************************************************************ add_class_to_loadable_list* Class cls has just become connected. Schedule it for +load if* it implements a +load method.**********************************************************************/void add_class_to_loadable_list(Class cls)&#123; IMP method; loadMethodLock.assertLocked(); method = cls-&gt;getLoadMethod(); if (!method) return; // Don&apos;t bother if cls has no +load method if (PrintLoading) &#123; _objc_inform(&quot;LOAD: class &apos;%s&apos; scheduled for +load&quot;, cls-&gt;nameForLogging()); &#125; if (loadable_classes_used == loadable_classes_allocated) &#123; loadable_classes_allocated = loadable_classes_allocated*2 + 16; loadable_classes = (struct loadable_class *) realloc(loadable_classes, loadable_classes_allocated * sizeof(struct loadable_class)); &#125; loadable_classes[loadable_classes_used].cls = cls; loadable_classes[loadable_classes_used].method = method; loadable_classes_used++;&#125;/************************************************************************ add_category_to_loadable_list* Category cat&apos;s parent class exists and the category has been attached* to its class. Schedule this category for +load after its parent class* becomes connected and has its own +load method called.**********************************************************************/void add_category_to_loadable_list(Category cat)&#123; IMP method; loadMethodLock.assertLocked(); method = _category_getLoadMethod(cat); // Don&apos;t bother if cat has no +load method if (!method) return; if (PrintLoading) &#123; _objc_inform(&quot;LOAD: category &apos;%s(%s)&apos; scheduled for +load&quot;, _category_getClassName(cat), _category_getName(cat)); &#125; if (loadable_categories_used == loadable_categories_allocated) &#123; loadable_categories_allocated = loadable_categories_allocated*2 + 16; loadable_categories = (struct loadable_category *) realloc(loadable_categories, loadable_categories_allocated * sizeof(struct loadable_category)); &#125; loadable_categories[loadable_categories_used].cat = cat; loadable_categories[loadable_categories_used].method = method; loadable_categories_used++;&#125; call_class_loads 和 call_category_loads 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/************************************************************************ call_class_loads* Call all pending class +load methods.* If new classes become loadable, +load is NOT called for them.** Called only by call_load_methods().**********************************************************************/static void call_class_loads(void)&#123; int i; // Detach current loadable list. struct loadable_class *classes = loadable_classes; int used = loadable_classes_used; loadable_classes = nil; loadable_classes_allocated = 0; loadable_classes_used = 0; // Call all +loads for the detached list. for (i = 0; i &lt; used; i++) &#123; Class cls = classes[i].cls; load_method_t load_method = (load_method_t)classes[i].method; if (!cls) continue; if (PrintLoading) &#123; _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging()); &#125; (*load_method)(cls, SEL_load); &#125; // Destroy the detached list. if (classes) free(classes);&#125;/************************************************************************ call_category_loads* Call some pending category +load methods.* The parent class of the +load-implementing categories has all of * its categories attached, in case some are lazily waiting for +initalize.* Don&apos;t call +load unless the parent class is connected.* If new categories become loadable, +load is NOT called, and they * are added to the end of the loadable list, and we return TRUE.* Return FALSE if no new categories became loadable.** Called only by call_load_methods().**********************************************************************/static bool call_category_loads(void)&#123; int i, shift; bool new_categories_added = NO; // Detach current loadable list. struct loadable_category *cats = loadable_categories; int used = loadable_categories_used; int allocated = loadable_categories_allocated; loadable_categories = nil; loadable_categories_allocated = 0; loadable_categories_used = 0; // Call all +loads for the detached list. for (i = 0; i &lt; used; i++) &#123; Category cat = cats[i].cat; load_method_t load_method = (load_method_t)cats[i].method; Class cls; if (!cat) continue; cls = _category_getClass(cat); if (cls &amp;&amp; cls-&gt;isLoadable()) &#123; if (PrintLoading) &#123; _objc_inform(&quot;LOAD: +[%s(%s) load]\n&quot;, cls-&gt;nameForLogging(), _category_getName(cat)); &#125; (*load_method)(cls, SEL_load); cats[i].cat = nil; &#125; &#125; // Compact detached list (order-preserving) shift = 0; for (i = 0; i &lt; used; i++) &#123; if (cats[i].cat) &#123; cats[i-shift] = cats[i]; &#125; else &#123; shift++; &#125; &#125; used -= shift; // Copy any new +load candidates from the new list to the detached list. new_categories_added = (loadable_categories_used &gt; 0); for (i = 0; i &lt; loadable_categories_used; i++) &#123; if (used == allocated) &#123; allocated = allocated*2 + 16; cats = (struct loadable_category *) realloc(cats, allocated * sizeof(struct loadable_category)); &#125; cats[used++] = loadable_categories[i]; &#125; // Destroy the new list. if (loadable_categories) free(loadable_categories); // Reattach the (now augmented) detached list. // But if there&apos;s nothing left to load, destroy the list. if (used) &#123; loadable_categories = cats; loadable_categories_used = used; loadable_categories_allocated = allocated; &#125; else &#123; if (cats) free(cats); loadable_categories = nil; loadable_categories_used = 0; loadable_categories_allocated = 0; &#125; if (PrintLoading) &#123; if (loadable_categories_used != 0) &#123; _objc_inform(&quot;LOAD: %d categories still waiting for +load\n&quot;, loadable_categories_used); &#125; &#125; return new_categories_added;&#125; +(void)initialize 的理解+(void)initialize 是在类或者它的子类收到第一条消息（实例方法、类方法）之前被调用的。 常见理论知识汇总 调用顺序：父类 &gt; 子类（或分类） 调用时机：Objective-C 运行时初始化时，每当有新的镜像library map 到运行时调用。 调用次数：多次，如果子类未实现+(void)initialize ，父类+(void)initialize 会被调用多次 线程安全：在initialize方法收到调用时，运行环境基本健全。initialize的运行过程中是能保证线程安全的。 常见场景：稍微广泛，初始化工作，或者单例模式的实现方案。 基于 runtime 源码分析lookUpImpOrForward当一个类收到消息时，runtime 会通过 IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver) 方法查找方法的实现返回函数指针 IMP，或者进行消息转发。123456789101112131415161718192021222324252627/************************************************************************ lookUpImpOrForward.* The standard IMP lookup. * initialize==NO tries to avoid +initialize (but sometimes fails)* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)* Most callers should use initialize==YES and cache==YES.* inst is an instance of cls or a subclass thereof, or nil if none is known. * If cls is an un-initialized metaclass then a non-nil inst is faster.* May return _objc_msgForward_impcache. IMPs destined for external use * must be converted to _objc_msgForward or _objc_msgForward_stret.* If you don&apos;t want forwarding at all, use lookUpImpOrNil() instead.**********************************************************************/IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; ... if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; _class_initialize (_class_getNonMetaClass(cls, inst)); // If sel == initialize, _class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won&apos;t happen. 2778172 &#125; ...&#125; _class_initialize如果类没有被初始化，会调用 _class_initialize 进行初始化，对入参的参数父类递归的调用 _class_initialize，这也就是父类优先子类调用的本质。是不是对「Talk is cheap. Show me the code.」深表体会；）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/************************************************************************ class_initialize. Send the &apos;+initialize&apos; message on demand to any* uninitialized class. Force initialization of superclasses first.**********************************************************************/void _class_initialize(Class cls)&#123; assert(!cls-&gt;isMetaClass()); Class supercls; bool reallyInitialize = NO; // Make sure super is done initializing BEFORE beginning to initialize cls. // See note about deadlock above. supercls = cls-&gt;superclass; if (supercls &amp;&amp; !supercls-&gt;isInitialized()) &#123; _class_initialize(supercls); &#125; // Try to atomically set CLS_INITIALIZING. &#123; monitor_locker_t lock(classInitLock); if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123; cls-&gt;setInitializing(); reallyInitialize = YES; &#125; &#125; if (reallyInitialize) &#123; // We successfully set the CLS_INITIALIZING bit. Initialize the class. // Record that we&apos;re initializing this class so we can message it. _setThisThreadIsInitializingClass(cls); // Send the +initialize message. // Note that +initialize is sent to the superclass (again) if // this class doesn&apos;t implement +initialize. 2157218 if (PrintInitializing) &#123; _objc_inform(&quot;INITIALIZE: calling +[%s initialize]&quot;, cls-&gt;nameForLogging()); &#125; // Exceptions: A +initialize call that throws an exception // is deemed to be a complete and successful +initialize. @try &#123; callInitialize(cls); if (PrintInitializing) &#123; _objc_inform(&quot;INITIALIZE: finished +[%s initialize]&quot;, cls-&gt;nameForLogging()); &#125; &#125; @catch (...) &#123; if (PrintInitializing) &#123; _objc_inform(&quot;INITIALIZE: +[%s initialize] threw an exception&quot;, cls-&gt;nameForLogging()); &#125; @throw; &#125; @finally &#123; // Done initializing. // If the superclass is also done initializing, then update // the info bits and notify waiting threads. // If not, update them later. (This can happen if this +initialize // was itself triggered from inside a superclass +initialize.) monitor_locker_t lock(classInitLock); if (!supercls || supercls-&gt;isInitialized()) &#123; _finishInitializing(cls, supercls); &#125; else &#123; _finishInitializingAfter(cls, supercls); &#125; &#125; return; &#125; else if (cls-&gt;isInitializing()) &#123; // We couldn&apos;t set INITIALIZING because INITIALIZING was already set. // If this thread set it earlier, continue normally. // If some other thread set it, block until initialize is done. // It&apos;s ok if INITIALIZING changes to INITIALIZED while we&apos;re here, // because we safely check for INITIALIZED inside the lock // before blocking. if (_thisThreadIsInitializingClass(cls)) &#123; return; &#125; else &#123; waitForInitializeToComplete(cls); return; &#125; &#125; else if (cls-&gt;isInitialized()) &#123; // Set CLS_INITIALIZING failed because someone else already // initialized the class. Continue normally. // NOTE this check must come AFTER the ISINITIALIZING case. // Otherwise: Another thread is initializing this class. ISINITIALIZED // is false. Skip this clause. Then the other thread finishes // initialization and sets INITIALIZING=no and INITIALIZED=yes. // Skip the ISINITIALIZING clause. Die horribly. return; &#125; else &#123; // We shouldn&apos;t be here. _objc_fatal(&quot;thread-safe class init in objc runtime is buggy!&quot;); &#125;&#125; callInitialize 中使用 objc_msgSend 方式对 +(void)initialize 进行调用，也就是和普通方法走消息发送的流程，如果子类没有实现，走父类的方法，如果分类实现，就会对主类进行“覆盖”，如果多个分类，不确定调用哪一个分类的同名方法，需要看编译的过程。12345void callInitialize(Class cls)&#123; ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize); asm(&quot;&quot;);&#125; Tips如果子类没有实现 +(void)initialize，父类会被调用多次，只想调用父类 initialize 一次呢。123456+ (void)initialize &#123; if (self == [ClassName self]) &#123; &#125;&#125;# 或者 dispatch_once 了 推荐文章 Objective-C Class Loading and Initialization Objective C类方法load和initialize的区别 Method Swizzling]]></content>
      <categories>
        <category>runtime</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Tutorial - NexT 主题配置和第三方服务]]></title>
    <url>%2F2018%2F01%2F03%2Fhexo-theme-tutorial%2F</url>
    <content type="text"><![CDATA[简谈 NexT 主题的配置和第三方的服务的接入。 前言前一篇完成了简单个人主页的搭建，然而，追求美的脚步和好奇心的滋生，难以遏制。 NexT 主题配置NexT 主题配置官网文档，有详尽的配置，如设置 RSS、设置字体、设置代码高亮主题、侧边栏社交链接、开启打赏功能、友情链接、腾讯公益404等。 添加标签页面1234# 进入站点根目录$cd your-hexo-site# 新建名为 tags 的页面$hexo new page tags 打开新建 tags 页面，将类型设为 tags。123456title: 标签date: 2017-12-30 12:39:04type: "tags"# 如果集成了评论服务，在标签页禁用该功能comments: false--- 编辑主题配置文件， 添加 tags 到 menu 中。1234menu: home: / archives: /archives tags: /tags 包含标签的文章12345title: 标签测试文章tags: - Testing - Another Tag--- 添加分类页面1234# 进入站点根目录$cd your-hexo-site# 新建名为 categories 的页面$hexo new page categories 打开新建 categories 页面，将类型设为 categories。123456title: 标签date: 2017-12-30 12:39:04type: "categories"# 如果集成了评论服务，在分类页禁用该功能comments: false--- 编辑主题配置文件， 添加 categories 到 menu 中。12345menu: home: / archives: /archives tags: /tags categories: /categories 包含分类的文章123title: 分类测试文章categories: Testing--- 添加 RSS 订阅因为已经有成熟的依赖模块，所以添加 RSS 订阅很简单，进入站点目录1$ npm install hexo-generator-feed --save 然后在主题配置目录配置文件中修改 RSS 配置，参见注释。1234# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: 在站点目录配置文件中，添加12345rss: /atom.xmlfeed: type: atom path: atom.xml limit: 20 The last but not least，在站点目录配置文件中，配置 URL 为自己网站的地址。123# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://grackanil.top 在上角添加fork me on github提供两个获取样式的站点，GitHub Ribbons和GitHub Corners考虑到适配移动端适配，重叠于菜单按钮，我取的是 GitHub Corners 的右上角的样式。12# 修改 https://your-url 、fill:#151513; 和 color:#fff;&lt;a href="https://your-url" class="github-corner" aria-label="View source on Github"&gt;&lt;svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"&gt;&lt;path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"&gt;&lt;/path&gt;&lt;path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"&gt;&lt;/path&gt;&lt;path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 粘贴样式代码至 themes/next/layout/_layout.swig 文件中&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下。 NexT 主题第三方服务接入Jiathis，网站社会化工具。注册 JiaThis，获取 uid。配置主题配置文件 JiaThis。1234567# Share# This plugin is more useful in China, make sure you known how to use it.# And you can find the use guide at official webiste: http://www.jiathis.com/.# Warning: JiaThis does not support https.jiathis: #Get this uid from http://www.jiathis.com/ uid: xxxxxx 不蒜子，网站计数。详细文档，配置好主题配置文件即可。1234567891011121314151617# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; page_pv_footer: ValineValine是一款基于leancloud的快速、简洁且高效的无后端评论系统。可以查看详细的 Valine 文档。 七牛云，作为文章图片对象存储。考虑到便于迁移博客，图床必须要，七牛访问速度快，支持日志，防盗链和水印。免费用户有10GB流量/每月+总空间10GB+PUT/DELETE 10万请求+GET 100万请求，对于个人主页足够了，另外，可以邀请好友获得奖励。这是我的邀请：）]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态网站托管服务平台]]></title>
    <url>%2F2018%2F01%2F03%2Fstatic-site-hosting-service%2F</url>
    <content type="text"><![CDATA[简要罗列静态网站托管平台。 前言最近使用Hexo和GitHub Pages搭建个人静态主页，发现一些问题，遂做一个横向方案比较，了解一下具体的异同。有很多平台没有亲自实践，所以说明仅供记录参考，细节有待挖掘和更新。同时，如果您有其他推荐的方案，欢迎评论分享，持续更新：) GitHub Pages 被设计为直接来源于GitHub仓库的个人、组织或项目主页。 提供静态网站托管服务 不支持服务端代码，比如 PHP、Ruby 或 Python GitHub Pages 提供的域名可以支持 HTTPS 访问 可以配置自定义的域名，但是无法给自定义的域名配置 SSL ，HTTPS is not supported for GitHub Pages using custom domains. 响应速度还是有点慢 网站仓库小于1GB，带宽限制 100GB/每月，构建限制10次/每小时 Netlify 不支持后台逻辑运算能力的网页 如果要部署 Hexo 大体思路是，通过 CLI (命令行界面)将 md 渲染为静态网站，然后通过 git 部署到 Git 平台，然后使用 Netlify 的 webhook 自动抓取部署 具有全球CDN、持续部署、一键HTTPS等优势 能通过客户端 JS 与可重用 API 可以带来动态功能，炫酷。 可以使用 Hugo 静态网站生成器和 Hetlify 网站自动化系统配合，以解决 Github Pages 的不支持 HTTPS 和 响应慢的问题 Coding Pages 由国内 Coding 提供 访问速度友好 可以做 GitHub Pages 和 Coding Pages 同时部署 Hexo，然后通过域名 DNS 解析，国外访问 GitHub Pages ，国内 访问 Coding Pages， 以优化访问速度 可以免费绑定多个自定义域名 自定义域名可以享有免费 SSL 证书，全站支持 HTTPS 协议 更新代码库就可以自动部署。服务器稳定，香港服务器国外支持也友好 新增动态页面部署 有一个小问题是，网站首页如果不放置官方『Hosted by Coding Pages』的链接，会系统添加中间『Hosted by Coding Pages』页面。 GitLab Pages 是由 GitLab 提供，旨在为 GitLab 工程、个人、groups 创建网站。 可以使用任何静态网站生成器，如 Jekyll、Middleman、Hexo、Hugo、Pelican等 可以配置自定义域名 HTTPS，需要的是上传证书 Now 不仅支持静态网站托管，也支持 JavaScript(Node.js) 或者 Docker 驱动的网站， 可以使用 CLI 或者链接 Git 仓库 支持自定义域名，开启 HTTPS 传输基于 HTTP/2 不需要安装 Git 等源代码控制工具，不需要设置 keys 或者 tokens 实时部署。 Firebase Hosting 只能 CLI 支持自定义域名并支持开启 HTTPS 支持重定向和重写。 Bitbucket Cloud 必须要通过 HTTPS 访问 不能自定义域名 所有项目的静态网站代码都只能放在专门的站点仓库里。 页面缓存 15 分钟，意味着改变不会立即可见。 aerobatic 可以支持 CLI 上传代码 自定义域名需要收费。 surge 只支持 CLI 支持自定义域名，开启 SSL 是需要收费，同时需要自己上传证书 持续更新…]]></content>
      <tags>
        <tag>static site</tag>
        <tag>comparision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Tutorial - 基本搭建和配置]]></title>
    <url>%2F2017%2F12%2F29%2Fhexo-tutorial%2F</url>
    <content type="text"><![CDATA[记录一次 Hexo 从零开始搭建的历程。 前言很早就了解到可以通过 GitHub 托管静态网页，使用 Hexo 和 GitHub Pages 方便快捷地搭建个人博客网站，也一直想通过一种方式整理和管理知识，遂从零开始搭建、配置属于自己的博客网站。 注册 GitHubGitHub 是一个面向开源及私有软件项目的托管平台。最好最详细的教程是 官方文档 望多查阅。以下是我简要说明，有错误还望指正包涵。 注册 验证邮箱登录注册邮箱，验证账号。 创建仓库 通过 SSH 建立连接，详见 文档 ，使用 SSH 协议，每次访问可以无需用户名和密码连接 GitHub 。检查是否已经存在 SSH keys打开终端，使用ls -al ~/.ssh查看，如果在.ssh目录下存在文件列表，说明已经存在 SSH keys 。1234567$ ls -al ~/.sshtotal 24drwx------ 5 gekang staff 160 9 26 10:03 .drwxr-xr-x+ 115 gekang staff 3680 12 31 14:04 ..-rw------- 1 gekang staff 1675 9 8 19:59 id_rsa-rw------- 1 gekang staff 398 9 8 19:59 id_rsa.pub-rw-r--r-- 1 gekang staff 2178 12 27 23:30 known_hosts 如果没有 public key ，生成 SSH；如果已经有了，直接配置即可1234# ssh-keygen -t rsa -C "yourmail@xxx.com"Generating public/private rsa key pair.&lt;!-- 直接输入回车即可 --&gt;Enter file in which to save the key (/root/.ssh/id_rsa): 要求输入密码，可以一路回车。123456789101112131415161718Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:Kf8+luLAnbCkfUxraCX88K9x4WJHqym+WItUPr5sr yourmail@xxx.comThe key's randomart image is:+---[RSA 2048]----+| || || o + || . B . . || + o X S || .* S @ o || .o.= @ O . || o+B = =..+ ||.+E+. ...+o. |+----[SHA256]-----+ 配置 SSH 找到 id_rsa.pub 中的 public key ，位置如上路径，复制出 public key。复制 public key 时，不要重起一行，添加空格，可以使用pbcopy &lt; ~/.ssh/id_rsa.pub复制到剪贴板 进入 GitHub Setting 页面，配置 SSH。 创建 SSH ，title 任意输入，粘贴 public key ，然后 Add SSH key。 测试连接1ssh -T git@github.com 可能看到警告：123The authenticity of host 'github.com (IP ADDRESS)' can't be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 或123The authenticity of host 'github.com (IP ADDRESS)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? 验证 fingerprint ,然后 type yes然后，12Hi username! You've successfully authenticated, but GitHub does notprovide shell access. 简述 GitHub PagesGitHub Pages是 GitHub 提供的一个静态网站托管服务。同样，官方文档是最好的教程。 GitHub Pages 可以用为两种类型：用户或组织主页；项目工程主页。 搭建个人主页，以username.github.io名创建仓库 克隆仓库到本地 本地编辑个人静态主页 Push 到远程仓库。此处说明，若使用 SSH ，创建 GitHub 已建立 SSH 连接，可以直接 Push；若无，建立连接，或者使用 Https 推送到远程仓库，其间需要输入用户名和密码。 以上若都成功，访问个人主页，https://username.github.io. 域名注册、绑定我的个人主页是万网注册的域名，所以简述万网域名购买和绑定。同样也有很详细的文档 注册登录阿里云购买域名，进入控制中心 管理域名，添加域名解析GitHub 推荐使用 www 的二级域名，给域名添加解析，记录类型都是 A 记录，记录值全部对应刚才 ping 出来的 IP 。 添加CNAME文件到github仓库由于hexo d部署时，依据.gitignore文件，会清除所有文件，所以如要将 CNAME 部署到 GitHub 中，必须将 CNAME 放置 source 文件夹中（可以放在后面 Hexo 安装后，初始化项目中 source 目录下）。CNAME 文件中是12345# 域名为grackanil.top# 二级域名www.grackanil.top# 一级域名grackanil.top Hexo 安装安装 Hexo 相当简单。官方文档 安装环境如果安装了 Node.js 和 Git，只需要使用 npm 即可完成 Hexo 的安装1$ npm install -g hexo-cli 如果没有安装 Node.js 和 Git，以下均为 Mac 环境下。12345678# 使用 brew 安装 gitbrew install git# 可以使用 cURL 安装 nvm$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh# 也可以 使用 Wget 安装 nvm$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh# 使用最佳安装方式：nvm 安装 Node.js$ nvm install stable 安装 Hexo1$ npm install -g hexo-cli 初始化 Hexo 建站1234567891011121314151617181920212223242526272829# 初始化 Hexo，会在目标文件夹建立网站所需要的所有文件$ hexo init &lt;folder&gt;# 进入项目目录$ cd &lt;folder&gt;# 安装依赖包$ npm install# 查看项目第一层目录$ tree -L 1.├── _config.yml├── node_modules├── package.json├── scaffolds├── source├── themes└── yarn.lock# 更改后清除静态文件夹的内容并删掉$ hexo clean # 本地启动服务# hexo generate ，生成静态文件到 public 文件夹$ hexo gINFO Start processing...INFO Generated: 2018/01/01/hello-world/index.htmlINFO 28 files generated in 916 ms# hexo server，在本地服务器运行$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 访问 http://localhost:4000/ 部署到 GitHub，前提是已经注册 GitHub，创建 username.github.io 仓库安装 GitHub 依赖插件1$ npm install hexo-deployer-git --save 配置更目录下的 _config.yml文件1234deploy: type: git repo: ssh://git@github.com/grackanil/grackanil.github.io branch: master 部署命令123# 部署，hexo deploy$ hexo d$ hexo d -g 访问个人主页访问 username.github.io，如 grackanil.github.io，根目录 source 下已经创建CNAME，绑定自定义域名，可以访问域名。 主题安装Hexo 安装主题很方便，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。以安装NexT为例，可以访问NexT主题文档。 下载主题1234# 进入站点目录$ cd your-hexo-site# checkout 代码$ git clone https://github.com/iissnan/hexo-theme-next themes/next 修改站点配置目录根目录下的站点配置文件 config.yml，区别于主题目录下的主题配置文件config.yml。启动主题1theme: next 验证主题使用 hexo clean 来清除 Hexo 的缓存，启动服务 hexo s --debug，待成功后，访问http://localhost:4000 小结至此，简单的 NexT 默认配置主题的 Hexo 静态个人主页就搭建完成了。]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
